##
## Fastlane configuration for the Nevis Mobile Authentication SDK Example App react iOS application.
## See https://docs.fastlane.tools
##

require "securerandom"
require "json"

default_platform(:ios)

app_identifier = "ch.nevis.mobile.authentication.sdk.react.example"
display_name = "Nevis Mobile Authentication SDK Example App React iOS"
keychain_password = SecureRandom.base64
ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"

def ensure_temp_keychain(name, password)
	delete_temp_keychain(name)
	create_temp_keychain(name, password)
end

def create_temp_keychain(name, password)
	create_keychain(
		name:,
		password:,
		unlock: true,
		timeout: 0,
		lock_when_sleeps: true
	)
end

def delete_temp_keychain(name)
	delete_keychain(name:) if File.exist? File.expand_path("~/Library/Keychains/#{name}-db")
end

def report_on_success(message)
	slack(
		message: "#{message}\nCheck build logs: #{ENV['CURRENT_BUILD_URL']}",
		slack_url: ENV["SLACK_WEBHOOK_URL"]
	) if ENV["SLACK_WEBHOOK_URL"]
end

def report_on_error(message, exception)
	slack(
		message: "#{message}\nCheck build logs: #{ENV['CURRENT_BUILD_URL']}",
		slack_url: ENV["SLACK_WEBHOOK_URL"],
		success: false,
		attachment_properties: {
			fields: [
				{
					title: "Error message",
					value: exception.to_s,
					short: false
				}
			]
		}
	) if ENV["SLACK_WEBHOOK_URL"]
	UI.user_error!(exception.to_s)
end

def prepare_podfile(private_pod_repository_url)
	filename = File.join("./../Podfile")
	File.open(filename, "r") do |original_lines|
		File.unlink(filename)
		File.open(filename, "w") do |new_lines|
			new_lines.write "source '#{private_pod_repository_url}'\n"
			new_lines.write(original_lines.read)
		end
	end
end

platform :ios do
	desc "Pull request build"
	desc "#### Options"
	desc " * **`new_arch_enabled`**: Enable new architecture for the build."
	desc ""
	lane :pr do |options|
		utilize_private_repos
		build(options)
	end

	desc "Continuous build"
	desc "#### Options"
	desc " * **`version`**: The version of the application."
	desc " * **`build_number`**: The build number of the application."
	desc ""
	lane :develop do |options|
		utilize_private_repos
		distribute(options)
	end

	desc "Release build"
	desc "#### Options"
	desc " * **`version`**: The version of the application."
	desc " * **`build_number`**: The build number of the application."
	desc ""
	lane :main do |options|
		distribute(options)
	end

	####
	#### Private lanes
	####

	desc "Utilize private repositories"
	desc ""
	private_lane :utilize_private_repos do
		private_pod_repository_url = ENV["PRIVATE_NATIVE_REPOSITORY_URL"]
		prepare_podfile(private_pod_repository_url) if private_pod_repository_url
	end

	desc "Build the application"
	desc "#### Options"
	desc " * **`new_arch_enabled`**: Enable new architecture for the build."
	desc ""
	private_lane :build do |options|
		new_arch_enabled = options[:new_arch_enabled].nil? ? true : get_boolean?(options[:new_arch_enabled])
		UI.message("Build Debug version")
		Dir.chdir("..") do
			Actions.sh("yarn ios:build:#{new_arch_enabled ? 'new' : 'old'}", error_callback: ->(result) {
				raise "❌ Build Debug version failed! Result: #{result}"
			})
		end
	end

	desc "Distribute the application"
	desc "#### Options"
	desc " * **`version`**: The version of the application."
	desc " * **`build_number`**: The build number of the application."
	desc " * **`new_arch_enabled`**: Enable new architecture for the build."
	desc ""
	private_lane :distribute do |options|
		new_arch_enabled = options[:new_arch_enabled].nil? ? true : get_boolean?(options[:new_arch_enabled])
		version = options[:version]
		build_number = options[:build_number]

		keychain_name = ENV["TEMP_KEYCHAIN_NAME"]
		ensure_temp_keychain(
			keychain_name,
			keychain_password
		)

		UI.message("Distributing #{display_name} #{version} (#{build_number}) 📦")

		increment_version_number(
			version_number: version
		)

		increment_build_number(
			build_number:
		)

		upload(destination: Destination::FIREBASE, new_arch_enabled:)
		upload(destination: Destination::TESTFLIGHT, new_arch_enabled:)

		delete_temp_keychain(keychain_name)
		report_on_success("#{display_name} build completed: #{version} (#{build_number}) ✅")
	rescue => e
		delete_temp_keychain(keychain_name)
		report_on_error("#{display_name} build failed ❌", e)
	end

	desc "Upload the application to the specified destination"
	desc "#### Options"
	desc " * **`destination`**: The destination to upload the application to."
	desc " * **`new_arch_enabled`**: Enable new architecture for the build."
	desc ""
	private_lane :upload do |options|
		new_arch_enabled = options[:new_arch_enabled].nil? ? true : get_boolean?(options[:new_arch_enabled])
		destination = options[:destination]
		keychain_name = ENV["TEMP_KEYCHAIN_NAME"]

		begin
			# Setup code signing
			match(
				type: getConfig(destination:, step: Step::MATCH),
				readonly: true,
				app_identifier:,
				git_url: ENV["MATCH_GIT_URL"],
				git_branch: "main",
				keychain_name:,
				keychain_password:
			)

			update_code_signing_settings(
				path: "nevis_mobile_authentication_sdk_example_app_react.xcodeproj",
				build_configurations: ["Release"],
				use_automatic_signing: false,
				team_id: ENV["DEVELOPER_PORTAL_TEAM_ID"],
				code_sign_identity: ENV["CODE_SIGNING_IDENTITY"],
				profile_name: ENV["sigh_#{app_identifier}_#{getConfig(destination:, step: Step::CODE_SIGN)}_profile-name"],
			)

			Dir.chdir("..") do
				Actions.sh("yarn pods:#{new_arch_enabled ? 'new' : 'old'}", error_callback: ->(result) {
					raise "❌ Pod install failed! Result: #{result}"
				})
			end

			# Build
			gym(
				workspace: "nevis_mobile_authentication_sdk_example_app_react.xcworkspace",
				scheme: "nevis_mobile_authentication_sdk_example_app_react",
				configuration: "Release",
				clean: true,
				skip_profile_detection: true,
				skip_package_dependencies_resolution: true,
				export_method: getConfig(destination:, step: Step::GYM),
				export_options: {
					provisioningProfiles: {
						app_identifier => "match #{getConfig(destination:, step: Step::PROVISIONING_PROFILE)} #{app_identifier}"
					}
				},
				xcargs: "OTHER_CODE_SIGN_FLAGS=\"--keychain=#{keychain_name}\""
			)

			# Distribute
			case destination
			when Destination::FIREBASE
				# Upload to Firebase
				firebase_app_distribution(
					app: ENV["FIREBASE_APP_ID_IOS"],
					ipa_path: "./nevis_mobile_authentication_sdk_example_app_react.ipa",
					groups: "developers, internal-testers, presales"
				)
			when Destination::TESTFLIGHT
				# Upload to TestFlight
				testflight_app_distribution
			else
				UI.user_error!("⚠️ provided destination: #{destination} is not supported")
			end
		rescue => e
			delete_temp_keychain(keychain_name)
			report_on_error("#{display_name} build failed ❌", e)
		end
	end

	desc "Upload the application to TestFlight"
	desc ""
	private_lane :testflight_app_distribution do
		# Get AppStoreConnect Credentials
		app_store_connect_api_key(
			key_id: ENV["CONNECT_API_KEY_ID"],
			issuer_id: ENV["CONNECT_API_ISSUER_ID"],
			key_content: ENV["CONNECT_API_KEY_CONTENT"],
			in_house: false
		)

		# Gather App Review Information
		beta_app_review_info = {}

		begin
			beta_app_review_info = JSON.parse(ENV["BETA_APP_REVIEW_INFO"])
		rescue JSON::ParserError
			puts "Could not parse 'BETA_APP_REVIEW_INFO', not setting beta_app_review_info for TestFlight."
		end

		# Upload App to TestFlight
		upload_to_testflight(
			beta_app_review_info:,
			beta_app_description: "https://github.com/nevissecurity/nevis-mobile-authentication-sdk-example-app-react",
			groups: "Nevis testers",
			changelog: "https://docs.nevis.net/mobilesdk/quickstart",
			distribute_external: true
		)
	end

	####
	#### Utilities
	####

	module Step
		MATCH = "match".freeze
		CODE_SIGN = "code_sign".freeze
		GYM = "gym".freeze
		PROVISIONING_PROFILE = "prov_profile".freeze
	end

	module Destination
		FIREBASE = "firebase".freeze
		TESTFLIGHT = "testflight".freeze
	end

	desc "Get configuration value"
	desc "#### Options"
	desc " * **`destination`**: The destination to upload the application to. Possible values, see Destination module."
	desc " * **`step`**: The step to get the configuration value for. Possible values, see Step module."
	desc ""
	private_lane :getConfig do |options|
		UI.user_error!("⚠️ destination is not provided") unless options[:destination]
		UI.user_error!("⚠️ step is not provided") unless options[:step]
		destination = options[:destination]
		step = options[:step]

		case [step, destination]
		when [Step::MATCH, Destination::FIREBASE], [Step::CODE_SIGN, Destination::FIREBASE]
			config = "adhoc"
		when [Step::MATCH, Destination::TESTFLIGHT], [Step::CODE_SIGN, Destination::TESTFLIGHT]
			config = "appstore"
		when [Step::GYM, Destination::FIREBASE]
			config = "ad-hoc"
		when [Step::GYM, Destination::TESTFLIGHT]
			config = "app-store"
		when [Step::PROVISIONING_PROFILE, Destination::FIREBASE]
			config = "AdHoc"
		when [Step::PROVISIONING_PROFILE, Destination::TESTFLIGHT]
			config = "AppStore"
		else
			UI.user_error!("⚠️ Could not get configuration value for: Step - #{step}, Destination - #{destination}")
		end
		config
	end

	desc "Determines the boolean value of the provided input parameter."
	desc "Returns true for 'true', 1, '1' and true values."
	desc ""
	desc "puts get_boolean?(nil)            -> false"
	desc "puts get_boolean?(1)              -> true"
	desc "puts get_boolean?(0)              -> false"
	desc "puts get_boolean?('')             -> false"
	desc "puts get_boolean?(false)          -> false"
	desc "puts get_boolean?(true)           -> true"
	desc "puts get_boolean?('false')        -> false"
	desc "puts get_boolean?('true')         -> true"
	desc "puts get_boolean?('some text')    -> false"
	desc "puts get_boolean?('1')            -> true"
	desc ""
	desc "@param [String, Boolean, #read] input the input to determine the boolean value of"
	desc "@return [boolean] the boolean value of the input"
	def get_boolean?(input)
		return false if input.nil?

		bool_input = input.to_s.downcase
		["true", "1"].include?(bool_input)
	end
end
